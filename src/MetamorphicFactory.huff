/// @title Metamorphic Factory
/// @notice SPDX-License-Identifier: MIT
/// @author asnared <https://github.com/abigger87>
/// @notice A factory to create metamorphic contracts
/// @notice Metamorphic contracts can be redeployed with new code to the same address
/// @notice Adapted from <https://github.com/0age/metamorphic>


/// -----------------------
///
/// How does Metamorphism work?
///
/// In the constructor, set up the initialization code for metamorphic contracts.
/// The bytes passed into the Metamorphic Factory is used to deploy any transient contracts,
/// which will deploy any metamorphic contracts that require the use of a constructor.
///
/// Metamorphic contract initialization code (29 bytes): 0x5860208158601c335a63aaf10f428752fa158151803b80938091923cf3
///
/// Breaking down the metamorphic contract initialization code
///
///  -----------------------
///
/// Format:
/// pc | op | name | [stack] | <memory> | // Description
///
///  -----------------------
///
/// 00 58 getpc           [0]                                                 <>            // Set the first stack item to zero (using the program counter (or pc) since it is zero)
/// 01 60 push1           [0]                                                 <>            // Pushes the next byte onto the stack
/// 02 20 outsize         [32, 0]                                             <>            // Value pushed to the stack: 32 (the length of word returned from staticcall)
/// 03 81 dup2            [0, 32, 0]                                          <>            // Duplicates the second stack item (0) (the position of word returned from staticcall)
/// 04 58 getpc           [4, 0, 32, 0]                                       <>            // Set fourth stack item to 4, length of selector given to staticcall
/// 05 60 push1           [4, 0, 32, 0]                                       <>            // Pushes the next byte onto the stack
/// 06 1c inpos           [28, 4, 32, 0]                                      <>            // Value pushed to stack: 28 (position of selector given to staticcall)
/// 07 33 caller          [caller, 28, 4, 0, 32, 0]                           <>            // Pushes msg.sender to the stack (target address for staticcall)
/// 08 5a gas             [gas, caller, 28, 4, 0, 32, 0]                      <>            // Pushes msg.gas to the stack (gas to forward for staticcall)
/// 09 63 push4           [gas, caller, 28, 4, 0, 32, 0]                      <>            // Pushes the next 4 bytes to the stack (the function selector)
/// 10 aaf10f42 selector  [0xaaf10f42, gas, caller, 28, 4, 0, 32, 0]          <>            // The 4byte function selector pushed to the stack
/// 11 87 dup8            [0, 0xaaf10f42, gas, caller, 28, 4, 0, 32, 0]       <>            // Push the offset where to store the function selector in memory
/// 12 52 mstore          [gas, caller, 28, 4, 0, 32, 0]                      <0xaaf10f42>  // Places the function selector in memory at location 0x00 using mstore
/// 13 fa staticcall      [result (1 if success), 0]                          <address>     // Calls staticcall (places address in memory)
/// 14 15 iszero          [result == 0, 0]                                    <address>     // Flips the success bit of the staticcall
/// 15 81 dup2            [0, result == 0, 0]                                 <address>     // Duplicates the second stack item (0) (the position of address in memory)
/// 16 51 mload           [address, result == 0, 0]                           <>            // Loads address from position in memory onto the stack
/// 17 80 dup1            [address, address, result == 0, 0]                  <>            // Duplicates the address on the stack (the address for extcodesize to read)
/// 18 3b extcodesize     [size, address, result == 0, 0]                     <>            // Gets the extcodesize of address and places on the stack
/// 19 80 dup1            [size, size, address, result == 0, 0]               <>            // Duplicates the size of code at the address (reordering stack for extcodecopy)
/// 20 93 swap4           [0, size, address, result == 0, size]               <>            // Swaps the size with 0 (reordering stack for extcodecopy)
/// 21 80 dup1            [0, 0, size, address, result == 0, size]            <>            // Duplicates the first stack item (reordering stack for extcodecopy)
/// 22 91 swap2           [size, 0, 0, address, result == 0, size]            <>            // Swaps the first and third stack items (reordering stack for extcodecopy)
/// 23 92 swap3           [address, 0, 0, size, result == 0, size]            <>            // Swaps the first and fourth stack item (reordering stack for extcodecopy)
/// 24 3c extcodecopy     [result == 0, size]                                 <code>        // Calls extcodecopy with four stack items (placing the runtime code in memory)
/// 25 f3 return          []                                                                // Return to deploy final code in memory
///
/// -----------------------


// Imports
#include "huffmate/data-structures/Hashmap.huff"
#include "huffmate/utils/CommonErrors.huff"

// Stateful Interface
#define function deployMetamorphicContract(bytes32, bytes calldata, bytes calldata) payable returns (address)
#define function deployMetamorphicContractFromExistingImplementation(bytes32, address, bytes calldata) external payable returns (address)
#define function deployMetamorphicContractWithConstructor(bytes32, bytes calldata) external payable returns (address)

// Viewable Interface
#define function getImplementation() view returns (address)
#define function getInitializationCode() view returns (bytes memory)
#define function getImplementationContractAddress(address) view returns (address)

#define function getMetamorphicContractInstanceInitializationCode(address) external view returns (bytes memory)
#define function findMetamorphicContractAddress(bytes32) external view returns (address)
#define function findTransientContractAddress(bytes32) external view returns (address)
#define function findMetamorphicContractAddressWithConstructor(bytes32) external view returns (address)

#define function getMetamorphicContractInitializationCode() external view returns (bytes memory)
#define function getMetamorphicContractInitializationCodeHash() external view returns (bytes32)
#define function getTransientContractInitializationCode() external view returns (bytes memory)
#define function getTransientContractInitializationCodeHash() external view returns (bytes32)


/// @notice Fires when a metamorphic contract is deployed by cloning another contract
#define event Metamorphosed(address metamorphicContract, address newImplementation)

/// @notice Fires when a metamorphic contract is deployed through a transient contract
#define event MetamorphosedWithConstructor(address metamorphicContract, address transientContract)

/// @notice Store the initialization code for metamorphic contracts
#define constant MEAMORPHIC_CONTRACT_INITIALIZATION_CODE = 0x5860208158601c335a63aaf10f428752fa158151803b80938091923cf3

/// @notice Store hash of the initialization code for metamorphic contracts as well
#define constant METAMORPHIC_CONTRACT_INITIALIZATION_CODE_HASH = 0x7e18b382dec96fdc3badcb1ca6258e4f14469630399ad6ccb243b0d9f5344366

/// @notice Store init code for transient contracts that deploy metamorphic contracts
#define constant TRANSIENT_CONTRACT_INITIALIZATION_CODE = FREE_MEMORY_POINTER()

/// @notice Store the hash of the initialization code for transient contracts as well
#define constant TRANSIENT_CONTRACT_INTIALIZALIZATION_CODE_HASH = FREE_MEMORY_POINTER()

/// @notice Maintain a mapping of metamorphic contracts to metamorphic implementations
/// @notice This is a mapping and should use the hashmap helpers: LOAD_ELEMENTS_FROM_KEYS and STORE_ELEMENT_FROM_KEYS
#define constant IMPLEMENTATIONS = FREE_MEMORY_POINTER()

/// @notice Maintain a mapping of transient contracts to metamorphic init codes
/// @notice This is a mapping and should use the hashmap helpers: LOAD_ELEMENTS_FROM_KEYS and STORE_ELEMENT_FROM_KEYS
#define constant INIT_CODES = FREE_MEMORY_POINTER()

/// @notice Internal
/// @notice Helper macro to copy the bytes memory constructor argument
#define macro _LOAD_CONSTRUCTOR_ARGS() = takes (0) returns (1) {
  // Input Stack: []
  // Output Stack: [memory location of initialization bytes]

  // Codecopy the bytecode
  codesize dup1 0x00 0x00     // [destOffset, offset, size, size]
  codecopy                    // [size]

  // Word-align the size
  0x10 add                    // [size + 0x10]
  0x20 swap1 div              // [(size + 0x10) / 0x20]
  0x20 mul                    // [((size + 0x10) / 0x20) * 0x20]

  // Iterate backwards until we find: 0x20 | size | bytes (where bytes.length == size)
  0x00                        // [i, size]
  loop:
    dup2 dup2                 // [i, size, i, size]
    0x20 add swap1 sub        // [size - (i + 0x20), i, size]
    mload dup2                // [i, bytecode[size - (i + 0x20)], i, size]
    // NOTE: we have to use less than here since the index is word aligned and bytes may not be
    swap1 lt                  // [bytecode[size - (i + 0x20)] < i, i, size]
    dup2 0x40 add             // [i + 0x40, bytecode[size - (i + 0x20)] == i, i, size]
    dup4 sub mload            // [bytecode[size - (i + 0x40)], bytecode[size - (i + 0x20)] == i, i, size]
    0x20 eq                   // [bytecode[size - (i + 0x40)] == 0x20, bytecode[size - (i + 0x20)] == i, i, size]
    and                       // [bytecode[size - (i + 0x40)] == 0x20 && bytecode[size - (i + 0x20)] == i, i, size]
    found jumpi               // [i, size]

    // Increment and revert on underflow
    0x20 add dup1 0x20 add    // [i + 0x40, i + 0x40, size]
    dup3 sub iszero iszero    // [size - (i + 0x40) > 0, i + 0x20, size]
    loop jumpi                // [i, size]

    0x00 dup1 revert          // _reverts_

  found:
   // Get the pointer to the bytes size
    0x20 add swap1 sub        // [size - i]
}

/// @notice Internal
/// @notice Saves bytes memory to storage
/// @param ptr The pointer to the storage location
#define macro _SAVE_BYTES_TO_STORAGE(ptr) = takes (1) returns (0) {
  // Input Stack: [bytes size loc]
  // Output Stack: []

  // Loop over the memory and save to storage
  dup1 mload                        // [size, loc]
  swap1 0x20 add                    // [bytes_ptr, size]
  0x00                              // [i, bytes_ptr, size]
  loop:
    0x20 add dup3 dup2 lt iszero    // [i + 0x20 >= size, i + 0x20, bytes_ptr, size]
    done jumpi                      // [i + 0x20, bytes_ptr, size]
    dup2 dup2 add

    // TODO::::

    <ptr> sstore

  done:
    // Clean the stack
    pop pop pop
}

/// @notice Internal
/// @notice Hashes the transient initialization code from storage
/// @param ptr The pointer to the storage location
#define macro _HASH_STORAGE_BYTES(ptr) = takes (0) returns (1) {
  // Input Stack: []
  // Output Stack: [hash]

  // TODO: Iterate over <ptr> storage bytes, save to memory, and hash

}

/// @notice Constructor
#define macro CONSTRUCTOR() = takes (0) returns (0) {
  // Load the transient initialization code from the creation code
  _LOAD_CONSTRUCTOR_ARGS()                                            // [transientContractInitializationCode]

  // Store the transient contract initialization code in storage
  _SAVE_BYTES_TO_STORAGE([TRANSIENT_CONTRACT_INITIALIZATION_CODE])    // []

  // Calculate the transient contract initialization code hash
  _HASH_STORAGE_BYTES([TRANSIENT_CONTRACT_INITIALIZATION_CODE])       // [hash]

  // Store the transient contract initialization code hash in storage
  [TRANSIENT_CONTRACT_INTIALIZALIZATION_CODE_HASH] sstore             // []
}

/// @notice The function dispatch (main contract entrypoint)
#define macro MAIN() = takes (0) returns (0) {
  // Load the function selector
  pc calldataload 0xE0 shr                                                                                        // [selector]

  // Dispatch Stateful Functions With Selector
  dup1 __FUNC_SIG(deployMetamorphicContract) eq deplyMContractJump jumpi                                          // [selector]
  dup1 __FUNC_SIG(deployMetamorphicContractFromExistingImplementation) eq deployMContractExistingJump jumpi       // [selector]
  dup1 __FUNC_SIG(deployMetamorphicContractWithConstructor) eq deployMContractConstructorJump jumpi               // [selector]

  // Dispatch Viewable Functions With Selector
  dup1 __FUNC_SIG(getImplementation) eq getImplJump jumpi                                                         // [selector]
  dup1 __FUNC_SIG(getInitializationCode) eq getInitJump jumpi                                                     // [selector]
  dup1 __FUNC_SIG(getImplementationContractAddress) eq getImplContJump jumpi                                      // [selector]

  dup1 __FUNC_SIG(getMetamorphicContractInstanceInitializationCode) eq getMInstanceInitCodeJump jumpi             // [selector]
  dup1 __FUNC_SIG(findMetamorphicContractAddress) eq findMContractAddressJump jumpi                               // [selector]
  dup1 __FUNC_SIG(findTransientContractAddress) eq findTContractAddressJump jumpi                                 // [selector]
  dup1 __FUNC_SIG(findMetamorphicContractAddressWithConstructor) eq findMContractAddressConstructorJump jumpi     // [selector]


  dup1 __FUNC_SIG(getMetamorphicContractInitializationCode) eq getMInitCodeJump jumpi                             // [selector]
  dup1 __FUNC_SIG(getMetamorphicContractInitializationCodeHash) eq getMInitCodeHashJump jumpi                     // [selector]
  dup1 __FUNC_SIG(getTransientContractInitializationCode) eq getTInitCodeJump jumpi                               // [selector]
  dup1 __FUNC_SIG(getTransientContractInitializationCodeHash) eq getTInitCodeHashJump jumpi                       // [selector]


  // Revert on invalid dispatch
  0x00 dup1 revert                                                                            // _reverts_

  // Jump Dests
  deplyMContractJump: DEPLOY_METAMORPHIC_CONTRACT()                                           // _stops_
  deployMContractExistingJump: DEPLOY_METAMORPHIC_CONTRACT_FROM_EXISTING()                    // _stops_
  deployMContractConstructorJump: DEPLOY_METAMORPHIC_CONTRACT_WITH_CONSTRUCTOR()              // _stops_

  getImplJump: GET_IMPLEMENTATION()                                                           // _stops_
  getInitJump: GET_INIT_CODE()                                                                // _stops_
  getImplContJump: GET_IMPLEMENTATION_FOR_ADDRESS()                                           // _stops_

  getMInstanceInitCodeJump: GET_CONTRACT_INIT_CODE()                                          // _stops_
  findMContractAddressJump: COMPUTE_METAMORPHIC_ADDRESS()                                     // _stops_
  findTContractAddressJump: COMPUTE_TRANSIENT_ADDRESS()                                       // _stops_
  findMContractAddressConstructorJump: COMPUTE_METAMORPHIC_ADDRESS_WITH_CONSTRUCTOR()         // _stops_

  getMInitCodeJump: GET_METAMORPHIC_INITIALIZATION_CODE()                                     // _stops_
  getMInitCodeHashJump: GET_METAMORPHIC_INITIALIZATION_CODE_HASH()                            // _stops_
  getTInitCodeJump: GET_TRANSIENT_INITIALIZATION_CODE()                                       // _stops_
  getTInitCodeHashJump: GET_TRANSIENT_INITIALIZATION_CODE_HASH()                              // _stops_
}


// ----------------------------------
// Stateful Functions
// ----------------------------------

/// @notice Stateful
/// @notice Equivalent of `deployMetamorphicContract`
/// @notice Deploy a metamorphic contract by submitting a given salt or nonce along
///         with the initialization code for the metamorphic contract, and
///         optionally provide calldata for initializing the new metamorphic contract.
///         To replace the contract, first selfdestruct the current contract, then call
///         with the same salt value and new initialization code (be aware that all
///         existing state will be wiped from the existing contract). Also note that
///         the first 20 bytes of the salt must match the calling address, which
///         prevents contracts from being created by unintended parties.
/// @param salt bytes32 The nonce that will be passed into the CREATE2 call and
///        thus will determine the resulant address of the metamorphic contract.
/// @param implementationContractInitializationCode bytes The initialization
///        code for the implementation contract for the metamorphic contract. It will
///        be used to deploy a new contract that the metamorphic contract will then
///        clone in its constructor.
/// @param metamorphicContractInitializationCalldata bytes An optional data
///        parameter that can be used to atomically initialize the metamorphic contract.
/// @return Address of the metamorphic contract that will be created.
#define macro DEPLOY_METAMORPHIC_CONTRACT() = takes (0) returns (0) {
  // Load the salt from calldata
  0x04 calldataload                                           // [bytes32(salt)]

  // Load the implementation contract init code to the same location in memory
  0x24 calldataload                                           // [&calldata[init_code], salt]
  dup1 calldataload                                           // [size, &calldata[init_code], salt]
  dup2 dup1 calldatacopy                                      // [&mem[init_code], salt]

  // Load the metamorphic contract init calldata to the same place in memory
  0x44 calldataload                                           // [&calldata[init_data], &mem[init_code], salt]
  dup1 calldataload                                           // [size, &calldata[init_data], &mem[init_code], salt]
  dup2 dup1 calldatacopy                                      // [&mem[init_data], &mem[init_code], salt]

  // Modifiers
  dup3 CONTAINS_CALLER()                                      // [&mem[init_data], &mem[init_code], salt]

  // Get the metamorphic contract address
  dup3 _COMPUTE_METAMORPHIC_ADDRESS()                         // [address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Deploy the implementation init code
  dup3 dup1 calldataload                                      // [init_code_size, &mem[init_code], address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  swap1 0x20 add 0x00                                         // [value, mem[init_code + 0x20], init_code_size, address(metamoprhicContract), mem[init_data], mem[init_code], salt]
  create                                                      // [address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Validate Creation
  dup1 validCreateJump jumpi                                  // [address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  CREATE_FAILED(0x00)                                         // _reverts_
  validCreateJump:

  // Store the implementation contract address
  dup1 dup3 [IMPLEMENTATIONS]
  STORE_ELEMENT_FROM_KEYS(0x00)

  // Deploy the metamorphic contract data with create2
  dup5                                                        // [salt, address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  [MEAMORPHIC_CONTRACT_INITIALIZATION_CODE] 0x00 mstore       // [salt, address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  0x1D                                                        // [size, salt ,address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  0x00                                                        // [offset, size, salt, address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  0x00                                                        // [value, offset, size, salt, address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  create2                                                     // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Validate the Creation
  dup3 dup2 eq validCreate2Jump                               // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  REVERT_CREATE_TWO_FAILED(0x00)                              // _reverts_
  validCreate2Jump:

  // If any data or value is provided
  dup4 mload iszero                                           // [init_data.length == 0, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  callvalue iszero and                                        // [msg.value == 0 && init_data.length == 0, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  emitEventJump jumpi                                         // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Initialize the new metamorphic contract
  0x00                                                        // [retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup1                                                        // [retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup6 mload                                                  // [argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup7 0x20 add                                               // [argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  callvalue                                                   // [value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup6                                                        // [address, value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  gas                                                         // [gas, address, value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  call                                                        // [success, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  
  // Validate call success
  emitEventJump jumpi                                         // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  INITIALIZATION_FAILED(0x00)                                 // _reverts_

  // Emit the Metamorphosed event
  emitEventJump:                                              // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  __EVENT_HASH(Metamorphosed) 0x00 0x00 log3                  // [address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Return the metamorphic contract address
  0x00 mstore                                                 // [&mem[init_data], &mem[init_code], salt]
  0x20 0x00 return                                            // _returns_
}

/// @notice Stateful
/// @notice Equivalent of `deployMetamorphicContractFromExistingImplementation`
/// @notice Deploy a metamorphic contract by submitting a given salt or nonce
///         along with the address of an existing implementation contract to clone, and
///         optionally provide calldata for initializing the new metamorphic contract.
///         To replace the contract, first selfdestruct the current contract, then call
///         with the same salt value and a new implementation address (be aware that
///         all existing state will be wiped from the existing contract). Also note
///         that the first 20 bytes of the salt must match the calling address, which
///         prevents contracts from being created by unintended parties.
/// @param salt bytes32 The nonce that will be passed into the CREATE2 call and
///        thus will determine the resulant address of the metamorphic contract.
/// @param implementationContract address The address of the existing
///        implementation contract to clone.
/// @param metamorphicContractInitializationCalldata bytes An optional data
///        parameter that can be used to atomically initialize the metamorphic
///        contract.
/// @return Address of the metamorphic contract that will be created.
#define macro DEPLOY_METAMORPHIC_CONTRACT_FROM_EXISTING() = takes (0) returns (0) {
  // Load the salt from calldata
  0x04 calldataload                                           // [bytes32(salt)]

  // Load the implementation contract address
  0x24 calldataload                                           // [implAddress, salt]

  // Load the metamorphic contract init calldata to the same place in memory
  0x44 calldataload                                           // [&calldata[init_data], implAddress, salt]
  dup1 calldataload                                           // [size, &calldata[init_data], implAddress, salt]
  dup2 dup1 calldatacopy                                      // [&mem[init_data], implAddress, salt]

  // Modifiers
  dup3 CONTAINS_CALLER()                                      // [&mem[init_data], implAddress, salt]

  // Get the metamorphic contract address
  dup3 _COMPUTE_METAMORPHIC_ADDRESS()                         // [address(metamoprhicContract), &mem[init_data], implAddress, salt]

  // Store the implementation address to be retrieved by the metamoprhic contract
  dup3 dup2 [IMPLEMENTATIONS]                                 // [slot, address(metamoprhicContract), implAddress, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  STORE_ELEMENT_FROM_KEYS(0x00)                               // [address(metamoprhicContract), &mem[init_data], implAddress, salt]

  // Deploy the metamorphic contract data with create2
  dup4                                                        // [salt, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  [MEAMORPHIC_CONTRACT_INITIALIZATION_CODE] 0x00 mstore       // [salt, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  0x1D                                                        // [size, salt, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  0x00                                                        // [offset, size, salt, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  0x00                                                        // [value, offset, size, salt, address(metamoprhicContract), &mem[init_data], implAddress, salt]
  create2                                                     // [address(newMetaContract), address(metamoprhicContract), &mem[init_data], implAddress, salt]

  // Validate the Creation
  dup2 dup2 eq validCreate2Jump                               // [address(newMetaContract), address(metamoprhicContract), &mem[init_data], implAddress, salt]
  REVERT_CREATE_TWO_FAILED(0x00)                              // _reverts_
  validCreate2Jump:                                           // [address(newMetaContract), address(metamoprhicContract), &mem[init_data], implAddress, salt]





  // If any data or value is provided
  dup4 mload iszero                                           // [init_data.length == 0, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  callvalue iszero and                                        // [msg.value == 0 && init_data.length == 0, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  emitEventJump jumpi                                         // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Initialize the new metamorphic contract
  0x00                                                        // [retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup1                                                        // [retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup6 mload                                                  // [argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup7 0x20 add                                               // [argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  callvalue                                                   // [value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  dup6                                                        // [address, value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  gas                                                         // [gas, address, value, argOffset, argSize, retOffset, retSize, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  call                                                        // [success, address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  
  // Validate call success
  emitEventJump jumpi                                         // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  INITIALIZATION_FAILED(0x00)                                 // _reverts_

  // Emit the Metamorphosed event
  emitEventJump:                                              // [address(newMetaContract), address(implContract), address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]
  __EVENT_HASH(Metamorphosed) 0x00 0x00 log3                  // [address(metamoprhicContract), &mem[init_data], &mem[init_code], salt]

  // Return the metamorphic contract address
  0x00 mstore                                                 // [&mem[init_data], &mem[init_code], salt]
  0x20 0x00 return                                            // _returns_



  // TODO: Initialize

  // TODO: Emit Metamorphosed

  // TODO: Return address(metamorphicContract)

}

/// @notice Stateful
/// @notice Equivalent of `deployMetamorphicContractWithConstructor`
/// @notice Deploy a metamorphic contract by submitting a given salt or nonce
///         along with the initialization code to a transient contract which will then
///         deploy the metamorphic contract before immediately selfdestructing. To
///         replace the metamorphic contract, first selfdestruct the current contract,
///         then call with the same salt value and new initialization code (be aware
///         that all existing state will be wiped from the existing contract). Also
///         note that the first 20 bytes of the salt must match the calling address,
///         which prevents contracts from being created by unintended parties.
/// @param salt bytes32 The nonce that will be passed into the CREATE2 call and
///        thus will determine the resulant address of the metamorphic contract.
/// @param initializationCode bytes The initialization code for the metamorphic
///        contract that will be deployed by the transient contract.
/// @return Address of the metamorphic contract that will be created.
#define macro DEPLOY_METAMORPHIC_CONTRACT_WITH_CONSTRUCTOR() = takes (0) returns (0) {
  // TODO:
}


// ----------------------------------
// Viewable Functions
// ----------------------------------


/// @notice View
/// @notice Equivalent of `getImplementation`
/// @notice Gets the implementation for the msg.sender
/// @notice Called by the constructor of each metamorphic contract
#define macro GET_IMPLEMENTATION() = takes (0) returns (0) {
  // Load the implementation from internal mapping
  caller [IMPLEMENTATIONS]            // [loc, msg.sender]
  LOAD_ELEMENTS_FROM_KEYS(0x00)       // [address(implementation)]

  // Return the implementation address
  0x00 mstore                         // []
  0x20 0x00 return                    // _returns_
}

/// @notice View
/// @notice Equivalent of `getInitializationCode`
/// @notice Gets the initialization code for the msg.sender
/// @notice Called by the constructor of each transient contract
#define macro GET_INIT_CODE() = takes (0) returns (0) {
  // Load the init code from the internal mapping
  caller [INIT_CODES]                 // [loc, msg.sender]
  LOAD_ELEMENT_FROM_KEYS(0x00)        // [init_code]

  // Return the initialization code
  0x00 mstore                         // []
  0x20 0x00 return                    // _returns_
}

/// @notice View
/// @notice Equivalent of `getImplementationContractAddress`
/// @notice Gets the implementation contract for a given metamorphic contract address
/// @param `metamorphic` The metamorphic contract address
#define macro GET_IMPLEMENTATION_FOR_ADDRESS() = takes (0) returns (0) {
  // Load the address from calldata
  0x04 calldataload                   // [address]
  [IMPLEMENTATIONS]                   // [loc, address]
  LOAD_ELEMENTS_FROM_KEYS(0x00)       // [implementation]

  // Return the implementation address
  0x00 mstore                         // []
  0x20 0x00 return                    // _returns_
}

/// @notice View
/// @notice Equivalent of `getMetamorphicContractInstanceInitializationCode`
/// @notice Gets the init code of a metamorphic contract instance
#define macro GET_CONTRACT_INIT_CODE() = takes (0) returns (0) {
  // Load the contract address from calldata
  0x04 calldataload                   // [contract]
  [INIT_CODES]                        // [loc, contract]
  LOAD_ELEMENT_FROM_KEYS(0x00)        // [init_code]

  // Return the init code
  0x00 mstore                         // []
  0x20 0x00 return                    // _returns_
}

/// @notice View
/// @notice Equivalent of `findMetamorphicContractAddress`
/// @notice Compute the address of the metamorphic contract that will be created upon submitting a given salt to the contract
#define macro COMPUTE_METAMORPHIC_ADDRESS() = takes (0) returns (0) {
  // Load the bytes32 salt from calldata
  0x04 calldataload                       // [salt]

  // Get the metamorphic contract address
  _COMPUTE_METAMORPHIC_ADDRESS()          // [address]

  // Return
  0x00 mstore                             // []
  0x20 0x00 return                        // _returns_
}

/// @notice View
/// @notice Equivalent of `findTransientContractAddress`
/// @notice Compute the address of the transient contract that will be created upon submitting a given salt to the contract
#define macro COMPUTE_TRANSIENT_ADDRESS() = takes (0) returns (0) {
  // Load the bytes32 salt from calldata
  0x04 calldataload                       // [salt]

  // Get the transient contract address
  _COMPUTE_TRANSIENT_ADDRESS()            // [address]

  // Return
  0x00 mstore                             // []
  0x20 0x00 return                        // _returns_
}

/// @notice View
/// @notice Equivalent of `findMetamorphicContractAddressWithConstructor`
/// @notice ompute the address of the metamorphic contract that will be created by the transient contract upon submitting a given salt to the contract
#define macro COMPUTE_METAMORPHIC_ADDRESS_WITH_CONSTRUCTOR() = takes (0) returns (0) {
  // Load the bytes32 salt from calldata
  0x04 calldataload                       // [salt]

  // Get the transient contract address
  _COMPUTE_TRANSIENT_ADDRESS()          // [address]

  // Compute the address of the metamorphic contract deployed via a transient contract
  _COMPUTE_ADDRESS_WITH_CONSTRUCTOR()     // [address]

  // Return
  0x00 mstore                             // []
  0x20 0x00 return                        // _returns_
}

/// @notice View
/// @notice Equivalent of `getMetamorphicContractInitializationCode`
/// @notice Retrieves the initialization code of metamorphic contracts
#define macro GET_METAMORPHIC_INITIALIZATION_CODE() = takes (0) returns (0) {
  [MEAMORPHIC_CONTRACT_INITIALIZATION_CODE]       // [init_code]
  0x00 mstore                                     // []
  0x20 0x00 return                                // _returns_
}

/// @notice View
/// @notice Equivalent of `getMetamorphicContractInitializationCodeHash`
/// @notice Retrieves the keccak256 hash of the initialization code of metamorphic contracts
#define macro GET_METAMORPHIC_INITIALIZATION_CODE_HASH() = takes (0) returns (0) {
  [METAMORPHIC_CONTRACT_INITIALIZATION_CODE_HASH]   // [hash]
  0x00 mstore                                       // []
  0x20 0x00 return                                  // _returns_
}

/// @notice View
/// @notice Equivalent of `getTransientContractInitializationCode`
/// @notice Retrieves the initialization code of transient contracts
#define macro GET_TRANSIENT_INITIALIZATION_CODE() = takes (0) returns (0) {
  // TODO: load bytes memory from storage @ TRANSIENT_CONTRACT_INITIALIZATION_CODE

  0x00 mstore       // []
  0x20 0x00 return  // _returns_
} 

/// @notice View
/// @notice Equivalent of `getTransientContractInitializationCodeHash`
/// @notice Retrieves the keccak256 hash of the initialization code of transient contracts
#define macro GET_TRANSIENT_INITIALIZATION_CODE_HASH() = takes (0) returns (0) {
  [TRANSIENT_CONTRACT_INTIALIZALIZATION_CODE_HASH]  // [hash]
  0x00 mstore                                       // []
  0x20 0x00 return                                  // _returns_
}


// ----------------------------------
// Internal Helpers
// ----------------------------------

#define constant CREATE_FAILED = 0x4352454154455f4641494c454400000000000000000000000000000000000000
#define constant CREATE_FAILED_LENGTH = 0x0d

#define constant CREATE_TWO_FAILED = 0x435245415445325f4641494c4544000000000000000000000000000000000000
#define constant CREATE_TWO_FAILED_LENGTH = 0x0e

#define constant INITIALIZATION_FAILED = 0x494e495449414c495a4154494f4e5f4641494c45440000000000000000000000 
#define constant INITIALIZATION_FAILED_LENGTH = 0x15

/// @notice Internal
/// @notice Reverts with "CREATE_FAILED"
#define macro REVERT_CREATE_FAILED(condition) = takes (0) returns (0) {
    [CREATE_FAILED]            // [errStr]
    [CREATE_FAILED_LENGTH]     // [errLen, errStr]
    <condition>                 // [cond, errLen, errStr]
    REQUIRE()                   // []
}

/// @notice Internal
/// @notice Reverts with "CREATE2_FAILED"
#define macro REVERT_CREATE_TWO_FAILED(condition) = takes (0) returns (0) {
    [CREATE_TWO_FAILED]            // [errStr]
    [CREATE_TWO_FAILED_LENGTH]     // [errLen, errStr]
    <condition>                    // [cond, errLen, errStr]
    REQUIRE()                      // []
}

/// @notice Internal
/// @notice Reverts with "INITIALIZATION_FAILED"
#define macro REVERT_INITIALIZATION_FAILED(condition) = takes (0) returns (0) {
    [INITIALIZATION_FAILED]            // [errStr]
    [INITIALIZATION_FAILED_LENGTH]     // [errLen, errStr]
    <condition>                        // [cond, errLen, errStr]
    REQUIRE()                          // []
}

/// @notice Internal
/// @notice Calculates the metamorphic contract address given a salt
#define macro _COMPUTE_METAMORPHIC_ADDRESS() = takes (1) returns (1) {
  // Input stack: [salt]
  // Output stack: [address]

  // Compute the address
  _COMPUTE_ADDRESS([METAMORPHIC_CONTRACT_INITIALIZATION_CODE_HASH])
}

/// @notice Internal
/// @notice Calculates the transient contract address given a salt
#define macro _COMPUTE_TRANSIENT_ADDRESS() = takes (1) returns (1) {
  // Input stack: [salt]
  // Output stack: [address]

  // Compute the address
  _COMPUTE_ADDRESS([TRANSIENT_CONTRACT_INITIALIZATION_CODE_HASH])
}

/// @notice Internal
/// @notice Calculates a contract address given a particular salt
#define macro _COMPUTE_ADDRESS(hash) = takes (1) returns (1) {
  // Input stack: [salt]
  // Output stack: [address]

  // Start with 0xff to distinguish from RLP
  // Stored in memory @ 0x1f:0x20 (the last byte of the first word)
  0xff 0x00 mstore                    // [salt]

  // Store this address @ 0x20:0x34
  address 0x60 shl 0x20 mstore        // [salt]

  // Store the salt @ 0x34:0x54
  0x34 mstore                         // []

  // Store the code hash @ 0x54:0x74
  <hash> 0x54 mstore                  // []

  // Hash the packed data
  0x55 0x1f sha3                      // [raw_hash]

  // Clean the upper 12 bytes (96 bits or 0x60)
  0x60 shl 0x60 shr                   // [address]
}

#define test TEST_COMPUTE_ADDRESS() = takes (0) returns (0) {
  // TODO: use a known pre-image to compute the deterministic address

}

/// @notice Internal
/// @notice Computes the address for a metamorphic contract address deployed via a transient contract given the address of the transient contract
#define macro _COMPUTE_ADDRESS_WITH_CONSTRUCTOR() = takes (1) returns (1) {
  // Input stack: [address]
  // Output stack: [address]

  // Store the first RLP byte @ 0x1f:0x20
  0xd6 0x00 mstore                  // [address]

  // Store the second RLP byte @ 0x20:0x21
  0x94 0xf8 shl 0x20 mstore         // [address]

  // Store the transient contract address @ 0x21:0x35
  0x21 mstore                       // []

  // Store the nonce @ 0x35:0x36
  0x01 0xf8 shl 0x35 mstore         // []

  // Hash the packed data
  0x17 0x1f sha3                    // [hash]

  // Clean the upper 12 bytes (96 bits or 0x60)
  0x60 shl 0x60 shr                 // [address]
}

#define test TEST_COMPUTE_ADDRESS_WITH_CONSTRUCTOR() = takes (0) returns (0) {
  // TODO: test

}

/// @notice Modifier to check that the first 20 bytes of a submitted salt match those of the calling account
/// @notice This provides protection against the salt being stolen by frontrunners or other attackers
#define macro CONTAINS_CALLER() = takes (1) returns (0) {
  // Input stack: [salt]
  0x60 shr                              // [calling_account]
  caller eq                             // [msg.sender == calling_account]
  __ValidCallingAccountJump jumpi       // []
    UNAUTHORIZED(0x00)                  // _reverts
  __ValidCallingAccountJump:            // []
}

#define test TEST_CONTAINS_VALID_CALLER() = takes (0) returns (0) {
  // Create a valid salt
  
}

#define test FAIL_INVALID_CALLER() = takes (0) returns (0) {
  // Invalid salt

}
